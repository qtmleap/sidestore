# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

platform :ios do
  desc "Sign IPA with certificates and profiles from match"
  lane :sign_ipa do |options|
    # Setup CI environment (creates temporary keychain automatically)
    setup_ci

    # Setup App Store Connect API Key
    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"],
      is_key_content_base64: true
    )

    # Determine match type
    match_type = case options[:cert_type]
      when "appstore" then "appstore"
      when "enterprise" then "enterprise"
      else "adhoc"
    end

    # Create new bundle_id with team_id suffix
    new_bundle_id = "#{options[:bundle_id]}.#{options[:team_id]}"
    UI.message("New Bundle ID: #{new_bundle_id}")

    # Extract IPA to find all nested bundle IDs (extensions)
    temp_dir = Dir.mktmpdir("ipa_extract")
    ipa_path = File.expand_path(options[:ipa_path])

    UI.message("IPA path: #{ipa_path}")

    # Unzip the IPA
    sh("unzip -q '#{ipa_path}' -d '#{temp_dir}'")

    # Find all bundle IDs in the IPA (main app + extensions)
    all_bundle_ids = []
    extension_bundle_ids = []

    # Find all Info.plist files and extract bundle IDs
    Dir.glob("#{temp_dir}/Payload/**/*.app/Info.plist").each do |plist|
      bundle_id_output = `/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "#{plist}" 2>/dev/null`.strip
      unless bundle_id_output.empty?
        # Transform to new bundle ID format
        # Original: com.atebits.Tweetie3 -> com.atebits.Tweetie3.TEAM_ID
        # Extension: com.atebits.Tweetie3.NotificationContentExtension -> com.atebits.Tweetie3.TEAM_ID.NotificationContentExtension
        if bundle_id_output.start_with?(options[:bundle_id])
          suffix = bundle_id_output.sub(options[:bundle_id], "")
          transformed_id = "#{new_bundle_id}#{suffix}"
          all_bundle_ids << transformed_id
          extension_bundle_ids << transformed_id unless suffix.empty?
          UI.message("Found bundle ID: #{bundle_id_output} -> #{transformed_id}")
        end
      end
    end

    # Also check for appex (app extensions)
    Dir.glob("#{temp_dir}/Payload/**/*.appex/Info.plist").each do |plist|
      bundle_id_output = `/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "#{plist}" 2>/dev/null`.strip
      unless bundle_id_output.empty?
        if bundle_id_output.start_with?(options[:bundle_id])
          suffix = bundle_id_output.sub(options[:bundle_id], "")
          transformed_id = "#{new_bundle_id}#{suffix}"
          all_bundle_ids << transformed_id
          extension_bundle_ids << transformed_id
          UI.message("Found extension bundle ID: #{bundle_id_output} -> #{transformed_id}")
        end
      end
    end

    all_bundle_ids.uniq!
    extension_bundle_ids.uniq!

    UI.message("All bundle IDs to provision: #{all_bundle_ids.join(', ')}")

    # Clean up temp directory
    FileUtils.rm_rf(temp_dir)

    # Fetch certificates and provisioning profiles using match for ALL bundle IDs
    # Note: App IDs must be created manually in Apple Developer Portal first
    match(
      git_url: ENV["MATCH_GIT_URL"],
      type: match_type,
      app_identifier: all_bundle_ids,
      team_id: options[:team_id],
      api_key: api_key,
      readonly: false
    )

    # Get provisioning profile paths for all bundle IDs
    profiles_dir = File.join(Dir.home, "Library", "MobileDevice", "Provisioning Profiles")

    # Build provisioning profile hash for resign action
    # Format: { "bundle_id" => "profile_path" }
    provisioning_profiles = {}

    all_bundle_ids.each do |bundle_id|
      profile_path = nil
      Dir.glob(File.join(profiles_dir, "*.mobileprovision")).each do |file|
        content = File.read(file)
        # Check if this profile contains the bundle ID
        if content.include?(bundle_id)
          profile_path = file
          UI.message("Found profile for #{bundle_id}: #{file}")
          break
        end
      end

      if profile_path
        provisioning_profiles[bundle_id] = profile_path
      else
        UI.important("Warning: Could not find profile for #{bundle_id}")
      end
    end

    UI.message("Provisioning profiles map: #{provisioning_profiles}")

    # Get the full signing identity from the keychain
    # Use security command to find the distribution certificate
    keychain_output = `security find-identity -v -p codesigning`
    UI.message("Available signing identities:\n#{keychain_output}")

    # Find Apple Distribution identity (match installs it with team name)
    signing_identity = nil
    keychain_output.each_line do |line|
      if line.include?("Apple Distribution") && line.include?(options[:team_id])
        # Extract the identity string between quotes
        match = line.match(/"([^"]+)"/)
        if match
          signing_identity = match[1]
          break
        end
      end
    end

    # Fallback to any Apple Distribution identity
    if signing_identity.nil?
      keychain_output.each_line do |line|
        if line.include?("Apple Distribution")
          match = line.match(/"([^"]+)"/)
          if match
            signing_identity = match[1]
            break
          end
        end
      end
    end

    UI.user_error!("Could not find Apple Distribution signing identity in keychain") if signing_identity.nil?

    UI.message("Signing identity: #{signing_identity}")
    UI.message("Provisioning profiles: #{provisioning_profiles}")

    # Resign the IPA with new bundle ID and all provisioning profiles
    resign(
      ipa: ipa_path,
      signing_identity: signing_identity,
      provisioning_profile: provisioning_profiles,
      use_app_entitlements: false
    )

    # Move resigned IPA to signed directory
    output_path = File.expand_path(options[:output_path])
    resigned_ipa = ipa_path.gsub(".ipa", "-resigned.ipa")
    if File.exist?(resigned_ipa)
      FileUtils.mv(resigned_ipa, output_path)
    else
      FileUtils.cp(ipa_path, output_path)
    end
  end

  desc "Fetch or generate Ad Hoc provisioning profiles"
  lane :match_adhoc do
    match(
      type: "adhoc",
      readonly: false
    )
  end

  desc "Resign IPA with Ad Hoc profile and upload to R2"
  lane :resign_and_upload do |options|
    ipa_path = options[:ipa_path]
    app_identifier = options[:app_identifier]

    unless ipa_path
      UI.user_error!("Please provide ipa_path parameter")
    end

    unless app_identifier
      UI.user_error!("Please provide app_identifier parameter")
    end

    # Create App Identifier if it doesn't exist
    produce(
      username: ENV["APPLE_ID"],
      app_identifier: app_identifier,
      skip_itc: true
    )

    # Generate Ad Hoc provisioning profile with all registered devices
    match(
      type: "adhoc",
      app_identifier: app_identifier,
      force_for_new_devices: true,
      readonly: false
    )

    # Get the provisioning profile path
    profile_path = lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING][app_identifier]

    # Resign the IPA
    resigned_ipa_path = resign(
      ipa: ipa_path,
      signing_identity: "Apple Distribution",
      provisioning_profile: profile_path
    )

    # Extract app info for R2 path
    bundle_id = app_identifier
    version = get_ipa_info_plist_value(ipa: resigned_ipa_path, key: "CFBundleShortVersionString")

    # Upload to R2 using wrangler
    r2_path = "#{bundle_id}/#{version}/app.ipa"

    sh("bun wrangler r2 object put app-distribution/#{r2_path} --file #{resigned_ipa_path}")

    UI.success("Successfully uploaded resigned IPA to R2: #{r2_path}")

    resigned_ipa_path
  end
end
