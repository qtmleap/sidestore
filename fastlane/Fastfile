# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

platform :ios do
  desc "Sign IPA with certificates and profiles from match"
  lane :sign_ipa do |options|
    # Setup CI environment (creates temporary keychain automatically)
    setup_ci

    # Setup App Store Connect API Key
    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"],
      is_key_content_base64: true
    )

    # Determine match type
    match_type = case options[:cert_type]
      when "appstore" then "appstore"
      when "enterprise" then "enterprise"
      else "adhoc"
    end

    # Create new bundle_id with team_id suffix
    new_bundle_id = "#{options[:bundle_id]}.#{options[:team_id]}"
    UI.message("New Bundle ID: #{new_bundle_id}")

    # Create App ID if it doesn't exist
    produce(
      username: ENV["APPLE_ID"],
      app_identifier: new_bundle_id,
      app_name: options[:app_name] || new_bundle_id,
      team_id: options[:team_id],
      skip_itc: true
    )

    # Fetch certificates and provisioning profiles using match
    match(
      git_url: ENV["MATCH_GIT_URL"],
      type: match_type,
      app_identifier: new_bundle_id,
      team_id: options[:team_id],
      api_key: api_key,
      readonly: false
    )

    # Get signing identity and provisioning profile
    signing_identity = ENV["sigh_#{new_bundle_id}_#{match_type}_certificate-name"] ||
                       lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]&.values&.first ||
                       ENV["FASTLANE_SIGNING_IDENTITY"]

    profile_path = ENV["sigh_#{new_bundle_id}_#{match_type}"] ||
                   lane_context[SharedValues::SIGH_PROFILE_PATH]

    UI.message("Signing identity: #{signing_identity}")
    UI.message("Profile path: #{profile_path}")

    # Resign the IPA with new bundle ID
    resign(
      ipa: options[:ipa_path],
      signing_identity: signing_identity,
      provisioning_profile: profile_path,
      bundle_id: new_bundle_id,
      use_app_entitlements: false
    )

    # Move resigned IPA to signed directory
    resigned_ipa = options[:ipa_path].gsub(".ipa", "-resigned.ipa")
    if File.exist?(resigned_ipa)
      FileUtils.mv(resigned_ipa, options[:output_path])
    else
      FileUtils.cp(options[:ipa_path], options[:output_path])
    end
  end

  desc "Fetch or generate Ad Hoc provisioning profiles"
  lane :match_adhoc do
    match(
      type: "adhoc",
      readonly: false
    )
  end

  desc "Resign IPA with Ad Hoc profile and upload to R2"
  lane :resign_and_upload do |options|
    ipa_path = options[:ipa_path]
    app_identifier = options[:app_identifier]

    unless ipa_path
      UI.user_error!("Please provide ipa_path parameter")
    end

    unless app_identifier
      UI.user_error!("Please provide app_identifier parameter")
    end

    # Create App Identifier if it doesn't exist
    produce(
      username: ENV["APPLE_ID"],
      app_identifier: app_identifier,
      skip_itc: true
    )

    # Generate Ad Hoc provisioning profile with all registered devices
    match(
      type: "adhoc",
      app_identifier: app_identifier,
      force_for_new_devices: true,
      readonly: false
    )

    # Get the provisioning profile path
    profile_path = lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING][app_identifier]

    # Resign the IPA
    resigned_ipa_path = resign(
      ipa: ipa_path,
      signing_identity: "Apple Distribution",
      provisioning_profile: profile_path
    )

    # Extract app info for R2 path
    bundle_id = app_identifier
    version = get_ipa_info_plist_value(ipa: resigned_ipa_path, key: "CFBundleShortVersionString")

    # Upload to R2 using wrangler
    r2_path = "#{bundle_id}/#{version}/app.ipa"

    sh("bun wrangler r2 object put app-distribution/#{r2_path} --file #{resigned_ipa_path}")

    UI.success("Successfully uploaded resigned IPA to R2: #{r2_path}")

    resigned_ipa_path
  end
end
