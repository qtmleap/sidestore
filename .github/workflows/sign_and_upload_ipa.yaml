name: Sign and Upload IPA to R2

on:
  workflow_dispatch:
    inputs:
      certificate_type:
        description: "Certificate type for signing"
        required: false
        type: choice
        default: "adhoc"
        options:
          - adhoc
          - enterprise
          - appstore
      app_filter:
        description: "Filter apps by ID (comma-separated, empty for all)"
        required: false
        type: string

jobs:
  prepare:
    name: Prepare app matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set matrix
        id: set-matrix
        run: |
          # Read apps from JSON file
          if [ -n "${{ inputs.app_filter }}" ]; then
            # Filter by app IDs
            FILTER="${{ inputs.app_filter }}"
            MATRIX=$(jq -c --arg filter "$FILTER" '
              .apps | map(select(.id as $id | $filter | split(",") | map(gsub("\\s+"; "")) | index($id)))
            ' .github/apps.json)
          else
            # All apps
            MATRIX=$(jq -c '.apps' .github/apps.json)
          fi

          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Apps to process:"
          echo "$MATRIX" | jq .

  sign-and-upload:
    name: Sign ${{ matrix.app.name }}
    needs: prepare
    runs-on: macos-14
    timeout-minutes: 30
    env:
      R2_BASE_URL: "https://app.qleap.jp"
      TEAM_ID: "5Q94QJ7G98"
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.prepare.outputs.matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: false

      - name: Install fastlane
        run: |
          gem install fastlane --no-document
          fastlane --version

      - name: Download unsigned IPA from R2
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          R2_BUCKET: ${{ secrets.R2_BUCKET_NAME || 'app-distribution' }}
        run: |
          mkdir -p unsigned signed

          # Download IPA directly from R2
          bunx wrangler r2 object get \
            "$R2_BUCKET/${{ matrix.app.id }}/${{ matrix.app.id }}.ipa" \
            --file unsigned/app.ipa \
            --remote

          echo "Downloaded IPA size: $(du -h unsigned/app.ipa | cut -f1)"

      - name: Sign IPA with fastlane
        env:
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_URL: "https://x-access-token:${{ secrets.MATCH_GIT_TOKEN }}@github.com/qtmleap/match.git"
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_KEY_ID }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_KEY }}
        run: |
          # Create fastlane directory and Fastfile
          mkdir -p fastlane
          cat > fastlane/Fastfile << 'FASTFILE'
          default_platform(:ios)

          platform :ios do
            desc "Fetch certificates and profiles, then resign IPA"
            lane :sign_ipa do |options|
              # Setup CI environment (creates temporary keychain automatically)
              setup_ci

              # Setup App Store Connect API Key
              api_key = app_store_connect_api_key(
                key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
                issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
                key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"],
                is_key_content_base64: true
              )

              # Determine match type
              match_type = case options[:cert_type]
                when "appstore" then "appstore"
                when "enterprise" then "enterprise"
                else "adhoc"
              end

              # Create new bundle_id with team_id suffix
              new_bundle_id = "#{options[:bundle_id]}.#{options[:team_id]}"
              UI.message("New Bundle ID: #{new_bundle_id}")

              # Create App ID if it doesn't exist
              produce(
                app_identifier: new_bundle_id,
                app_name: options[:app_name] || new_bundle_id,
                team_id: options[:team_id],
                api_key: api_key,
                skip_itc: true  # Don't create on App Store Connect, just Developer Portal
              )

              # Fetch certificates and provisioning profiles using match
              # readonly: false allows creating new profiles if they don't exist
              match(
                git_url: ENV["MATCH_GIT_URL"],
                type: match_type,
                app_identifier: new_bundle_id,
                team_id: options[:team_id],
                api_key: api_key,
                readonly: false
              )

              # Get signing identity and provisioning profile
              signing_identity = ENV["sigh_#{new_bundle_id}_#{match_type}_certificate-name"] ||
                                 lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]&.values&.first ||
                                 ENV["FASTLANE_SIGNING_IDENTITY"]

              profile_path = ENV["sigh_#{new_bundle_id}_#{match_type}"] ||
                             lane_context[SharedValues::SIGH_PROFILE_PATH]

              UI.message("Signing identity: #{signing_identity}")
              UI.message("Profile path: #{profile_path}")

              # Resign the IPA with new bundle ID
              resign(
                ipa: options[:ipa_path],
                signing_identity: signing_identity,
                provisioning_profile: profile_path,
                bundle_id: new_bundle_id,
                use_app_entitlements: false
              )

              # Move resigned IPA to signed directory
              resigned_ipa = options[:ipa_path].gsub(".ipa", "-resigned.ipa")
              if File.exist?(resigned_ipa)
                FileUtils.mv(resigned_ipa, options[:output_path])
              else
                FileUtils.cp(options[:ipa_path], options[:output_path])
              end
            end
          end
          FASTFILE

          # Run fastlane
          fastlane ios sign_ipa \
            cert_type:"${{ inputs.certificate_type }}" \
            bundle_id:"${{ matrix.app.bundle_id }}" \
            team_id:"${TEAM_ID}" \
            ipa_path:"unsigned/app.ipa" \
            output_path:"signed/app.ipa"

          echo "✅ Signed IPA created"
          echo "Signed IPA size: $(du -h signed/app.ipa | cut -f1)"

      - name: Upload to R2
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          R2_BUCKET: ${{ secrets.R2_BUCKET_NAME || 'app-distribution' }}
        run: |
          bunx wrangler r2 object put \
            "$R2_BUCKET/${{ matrix.app.id }}/${{ matrix.app.id }}.ipa" \
            --file signed/app.ipa \
            --content-type "application/octet-stream" \
            --remote

          echo "✅ Uploaded: ${{ matrix.app.id }}/${{ matrix.app.id }}.ipa"

      - name: Summary
        run: |
          echo "## ✅ ${{ matrix.app.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| App ID | ${{ matrix.app.id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Bundle ID | ${{ matrix.app.bundle_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${R2_BASE_URL}/${{ matrix.app.id }}/${{ matrix.app.id }}.ipa |" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          rm -rf fastlane

      - name: Upload artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: signed-ipa-${{ matrix.app.id }}
          path: signed/app.ipa
          retention-days: 30
